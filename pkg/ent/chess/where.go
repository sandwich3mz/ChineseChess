// Code generated by ent, DO NOT EDIT.

package chess

import (
	"chesss/pkg/ent/predicate"

	"entgo.io/ent/dialect/sql"
)

// ID filters vertices based on their ID field.
func ID(id int64) predicate.Chess {
	return predicate.Chess(sql.FieldEQ(FieldID, id))
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int64) predicate.Chess {
	return predicate.Chess(sql.FieldEQ(FieldID, id))
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int64) predicate.Chess {
	return predicate.Chess(sql.FieldNEQ(FieldID, id))
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int64) predicate.Chess {
	return predicate.Chess(sql.FieldIn(FieldID, ids...))
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int64) predicate.Chess {
	return predicate.Chess(sql.FieldNotIn(FieldID, ids...))
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int64) predicate.Chess {
	return predicate.Chess(sql.FieldGT(FieldID, id))
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int64) predicate.Chess {
	return predicate.Chess(sql.FieldGTE(FieldID, id))
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int64) predicate.Chess {
	return predicate.Chess(sql.FieldLT(FieldID, id))
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int64) predicate.Chess {
	return predicate.Chess(sql.FieldLTE(FieldID, id))
}

// Before applies equality check predicate on the "before" field. It's identical to BeforeEQ.
func Before(v string) predicate.Chess {
	return predicate.Chess(sql.FieldEQ(FieldBefore, v))
}

// After applies equality check predicate on the "after" field. It's identical to AfterEQ.
func After(v string) predicate.Chess {
	return predicate.Chess(sql.FieldEQ(FieldAfter, v))
}

// Count applies equality check predicate on the "count" field. It's identical to CountEQ.
func Count(v int64) predicate.Chess {
	return predicate.Chess(sql.FieldEQ(FieldCount, v))
}

// BeforeEQ applies the EQ predicate on the "before" field.
func BeforeEQ(v string) predicate.Chess {
	return predicate.Chess(sql.FieldEQ(FieldBefore, v))
}

// BeforeNEQ applies the NEQ predicate on the "before" field.
func BeforeNEQ(v string) predicate.Chess {
	return predicate.Chess(sql.FieldNEQ(FieldBefore, v))
}

// BeforeIn applies the In predicate on the "before" field.
func BeforeIn(vs ...string) predicate.Chess {
	return predicate.Chess(sql.FieldIn(FieldBefore, vs...))
}

// BeforeNotIn applies the NotIn predicate on the "before" field.
func BeforeNotIn(vs ...string) predicate.Chess {
	return predicate.Chess(sql.FieldNotIn(FieldBefore, vs...))
}

// BeforeGT applies the GT predicate on the "before" field.
func BeforeGT(v string) predicate.Chess {
	return predicate.Chess(sql.FieldGT(FieldBefore, v))
}

// BeforeGTE applies the GTE predicate on the "before" field.
func BeforeGTE(v string) predicate.Chess {
	return predicate.Chess(sql.FieldGTE(FieldBefore, v))
}

// BeforeLT applies the LT predicate on the "before" field.
func BeforeLT(v string) predicate.Chess {
	return predicate.Chess(sql.FieldLT(FieldBefore, v))
}

// BeforeLTE applies the LTE predicate on the "before" field.
func BeforeLTE(v string) predicate.Chess {
	return predicate.Chess(sql.FieldLTE(FieldBefore, v))
}

// BeforeContains applies the Contains predicate on the "before" field.
func BeforeContains(v string) predicate.Chess {
	return predicate.Chess(sql.FieldContains(FieldBefore, v))
}

// BeforeHasPrefix applies the HasPrefix predicate on the "before" field.
func BeforeHasPrefix(v string) predicate.Chess {
	return predicate.Chess(sql.FieldHasPrefix(FieldBefore, v))
}

// BeforeHasSuffix applies the HasSuffix predicate on the "before" field.
func BeforeHasSuffix(v string) predicate.Chess {
	return predicate.Chess(sql.FieldHasSuffix(FieldBefore, v))
}

// BeforeEqualFold applies the EqualFold predicate on the "before" field.
func BeforeEqualFold(v string) predicate.Chess {
	return predicate.Chess(sql.FieldEqualFold(FieldBefore, v))
}

// BeforeContainsFold applies the ContainsFold predicate on the "before" field.
func BeforeContainsFold(v string) predicate.Chess {
	return predicate.Chess(sql.FieldContainsFold(FieldBefore, v))
}

// AfterEQ applies the EQ predicate on the "after" field.
func AfterEQ(v string) predicate.Chess {
	return predicate.Chess(sql.FieldEQ(FieldAfter, v))
}

// AfterNEQ applies the NEQ predicate on the "after" field.
func AfterNEQ(v string) predicate.Chess {
	return predicate.Chess(sql.FieldNEQ(FieldAfter, v))
}

// AfterIn applies the In predicate on the "after" field.
func AfterIn(vs ...string) predicate.Chess {
	return predicate.Chess(sql.FieldIn(FieldAfter, vs...))
}

// AfterNotIn applies the NotIn predicate on the "after" field.
func AfterNotIn(vs ...string) predicate.Chess {
	return predicate.Chess(sql.FieldNotIn(FieldAfter, vs...))
}

// AfterGT applies the GT predicate on the "after" field.
func AfterGT(v string) predicate.Chess {
	return predicate.Chess(sql.FieldGT(FieldAfter, v))
}

// AfterGTE applies the GTE predicate on the "after" field.
func AfterGTE(v string) predicate.Chess {
	return predicate.Chess(sql.FieldGTE(FieldAfter, v))
}

// AfterLT applies the LT predicate on the "after" field.
func AfterLT(v string) predicate.Chess {
	return predicate.Chess(sql.FieldLT(FieldAfter, v))
}

// AfterLTE applies the LTE predicate on the "after" field.
func AfterLTE(v string) predicate.Chess {
	return predicate.Chess(sql.FieldLTE(FieldAfter, v))
}

// AfterContains applies the Contains predicate on the "after" field.
func AfterContains(v string) predicate.Chess {
	return predicate.Chess(sql.FieldContains(FieldAfter, v))
}

// AfterHasPrefix applies the HasPrefix predicate on the "after" field.
func AfterHasPrefix(v string) predicate.Chess {
	return predicate.Chess(sql.FieldHasPrefix(FieldAfter, v))
}

// AfterHasSuffix applies the HasSuffix predicate on the "after" field.
func AfterHasSuffix(v string) predicate.Chess {
	return predicate.Chess(sql.FieldHasSuffix(FieldAfter, v))
}

// AfterEqualFold applies the EqualFold predicate on the "after" field.
func AfterEqualFold(v string) predicate.Chess {
	return predicate.Chess(sql.FieldEqualFold(FieldAfter, v))
}

// AfterContainsFold applies the ContainsFold predicate on the "after" field.
func AfterContainsFold(v string) predicate.Chess {
	return predicate.Chess(sql.FieldContainsFold(FieldAfter, v))
}

// CountEQ applies the EQ predicate on the "count" field.
func CountEQ(v int64) predicate.Chess {
	return predicate.Chess(sql.FieldEQ(FieldCount, v))
}

// CountNEQ applies the NEQ predicate on the "count" field.
func CountNEQ(v int64) predicate.Chess {
	return predicate.Chess(sql.FieldNEQ(FieldCount, v))
}

// CountIn applies the In predicate on the "count" field.
func CountIn(vs ...int64) predicate.Chess {
	return predicate.Chess(sql.FieldIn(FieldCount, vs...))
}

// CountNotIn applies the NotIn predicate on the "count" field.
func CountNotIn(vs ...int64) predicate.Chess {
	return predicate.Chess(sql.FieldNotIn(FieldCount, vs...))
}

// CountGT applies the GT predicate on the "count" field.
func CountGT(v int64) predicate.Chess {
	return predicate.Chess(sql.FieldGT(FieldCount, v))
}

// CountGTE applies the GTE predicate on the "count" field.
func CountGTE(v int64) predicate.Chess {
	return predicate.Chess(sql.FieldGTE(FieldCount, v))
}

// CountLT applies the LT predicate on the "count" field.
func CountLT(v int64) predicate.Chess {
	return predicate.Chess(sql.FieldLT(FieldCount, v))
}

// CountLTE applies the LTE predicate on the "count" field.
func CountLTE(v int64) predicate.Chess {
	return predicate.Chess(sql.FieldLTE(FieldCount, v))
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Chess) predicate.Chess {
	return predicate.Chess(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Chess) predicate.Chess {
	return predicate.Chess(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Chess) predicate.Chess {
	return predicate.Chess(func(s *sql.Selector) {
		p(s.Not())
	})
}
